### 1.1 时间复杂度的定义
- 在进行算法分析时，语句总的执行次数 `T(n)` 是关于问题规模 `n` 的函数，进而分析 `T(n)` 随 `n` 的变化情况并确定 `T(n)` 的数量级。<br>
算法的时间复杂度，也就是算法的时间量度，记作：`T(n) = O(f(n))`。
- 执行次数 == 时间，这样用大写 `O()` 来体现算法时间复杂度的记法，我们称之为`大O记法`。
- 一般情况下，随着输入规模 n 的增大，`T(N)` 增长最慢的算法为`最优算法`。

### 1.2 推导大O阶方法
- 用常数`1`取代运行时间中的所有加法常数
- 在修改后的运行次数函数中，只保留最高阶项
- 如果最高项存在且不是`1`，则去除与这个项相乘的常数
- 得到的最后结构就是`大O阶`

### 1.3 举例
- 常数阶`O(1)`
```
// 高斯算法
 let i = 1, n = 100, sum = 0;
 sum = (i + 100) * (n / 2);
```
- 线性阶`O(n)`
```
let n = 100, sum = 0;
for (let i = 0; i < n; i++) {
    sum += i;
}
```
- 平方阶 `O(n^2)`
```
let n = 100, sum = 0;
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        console.log('Hello World');
    }
}
```
- 对数阶`O(log n)`
```
let i = 1, n = 100;
while(i < n) {
    i = i * 2;
}
// 当2^x = n，即 n = log(2)时，结束循环；
// 所以时间复杂度 O(log n) 
```
### 1.4 函数调用的时间复杂度分析
```
int i;
for (i = 0; i < n; i++) {
    function(i);
}
void function(int count) {
    printf("%d", count);
}
// function的时间复杂度为O(1);
// 所以整体的时间复杂度为O(n)
```
将`function`改成如下，则时间复杂度为`O(n^2)`
```
int i, n;
for (i = 0; i < n; i++) {
    function(i);
}
void function(int count) {
    int j;
    for (j = count; j < n; j++) {
        printf("%d", j);
    }
}
```
### 1.5 常见的时间复杂度

例子 | 时间复杂度 | 说法
---|---|---
123456 | 0(1) | 常数阶
3n + 4 | 0(n) | 线性阶
3n^2 + 4n + 5 | 0(n^2) | 平方阶
3log(2)n+4 | 0(logn) | 对数阶
2n+3nlog(2) | 0(nlog n) | nlog阶
n^3 + 2n^2 + 4n + 6 | O(n^3) | 立方阶
2^n | 0(2^n) | 指数阶

- 常用时间复杂度所耗费的时间从小到大排列
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) <O(n^n);

### 1.6 算法的空间复杂度

- 定义：算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的公式记作：`S(n) = O(f(n))`;<br>
其中，`n`为问题的规模，`f(n)`为语句关于`n`所在存储空间的函数 
- 通常，我们都是用`时间复杂度`来指运行时间的需求,用`空间复杂度`指空间的需求